## 所有权规则

* 每个值都有一个变量，这个变量是该值的所有者
* 每个值同时只能有一个所有者。
* 当所有者超出作用域（scope)时，该值将被删除。

## 变量作用域

* Scope 就是程序中一个项目的有效范围
如：
```
fn main() {
    // s 不可用
    let s = "hello"; // s 可用
    // 可以对s进行操作
}// s 作用域到此结束，s 不再可用
```

### String 类型
* string 比那些基础数据类型更复杂
* 字符串字面值：程序里手写的那些字符串值。他们是不可变的
* Rust 还有第三种数据类型：String
    * 在heap 上分配。能够存储在编译时未知数量的文本

### 创建String 类型的值
* 可以使用from 函数从字符串字面值创建出String 类型。
* let s = String::from("hello");
    * "::" 表示from 是String 类型下的函数
* 这类字符串是可以被修改的
如：
```
fn main() {
    let mut s  = String::from("hello");
    s.push_str(", world");
    println!("{}", s);
}
```
* 为什么String类型的字面值可以修改，而字符串字面值却不能修改？
    * 因为他们处理内存的方式不通

### 内存和分配

* 字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终到可执行文件里。
    * 速度快、高效。是因为其不可变性
* String 类型，为了支持可变性，需要在heap 上分配内存来保存编译时未知的文本内容。
    * 操作系统必须在运行时来请求内存。
        * 这步调用Strig::from 来实现。
    * 当用完String 之后，需要使用某种方式将内存返回给操作系统
        * 这步，在拥有GC的语言中，GC 会跟踪并清理不再使用的内存。
        * 没有GC，就需要我们取识别内存何时不再使用，并调用代码将它返回。
            * 如果忘了，内存就会浪费
            * 如果提前做了，变量就会非法。
            *如果做了两次，也就是Bug，必须一次分配对应一次释放。

### Rust 内存方案
* Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统
* drop 函数

### 变量和数据交互的方式：移动（Move）
* 多个变量可以与同一个数据使用一种特殊的方式来交互。
* 
```
let x =  5;
let y = x;
```
* 整数是已知且固定大小的简单的值，这两个5被压到了stack 中。

### String 的移动（Move）
```
let s1 = String::from("hello");
let s2 = s1;
```
* 一个String 由三部分组成：
    * 一个指向存放字符串内容的内容的内存指针
    * 一个长度
    *  一个容量
* 上面这些东西存放在stack 上
* 存放字符串内容的部分在heap 上
* 长度为len，就是存放字符串内容所需字节数。
* 容量 capacity 是指String从操作系统总共获得内存的总字节数。
<img style="display: block; margin: 0 auto;" src="../img/String_heap.png" alt="" />