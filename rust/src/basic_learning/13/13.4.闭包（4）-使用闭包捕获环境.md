## 13.4.闭包(4):使用闭包捕获环境

### 闭包可以捕获所在环境

* 闭包可以访问定义他的作用域内的变量，而普通函数则不能。如：
    ```
    fn main() {
        let x = 8;
        let equal_to_x = |z| z == x;
        // fn equal_to_y(z:i32) -> bool {
        //     x == z
        // };
        let y = 8;
        assert!(equal_to_x(y))
    }
    ```
* 捕获环境会产生内存开销，大多数情况下不需要捕获环境也不需要额外为他产生内存开销，所以函数不允许从环境中捕获变量。

### 闭包从所在环境捕获值的方法

#### 与函数获得参数的三种方式一样

* 取得所有权：FnOnce
* 可变引用：FnMut
* 不可变借用：Fn

#### 创建闭包时，通过闭包对环境值的使用，Rust推断出具体使用后哪个Trait:

* 所有的闭包都实现了FnOnce
* 没有移动捕获变量的实现了FnMut
* 无需可变访问捕获变量的闭包实现了 Fn

### Move

* 在参数列表前使用move关键字，可以强制闭包取得它所使用的环境值的所有权。
    * 当将闭包传递给新线程以移动数据使其归新线程所有时，此方法最有用。
    ```
    fn move_equal() {
        let x = vec![1,2,3];
        // x 移动到了 闭包内，之后不可再使用
        let equal_to_x = move |z| z == x;
        println!("can't use x here,{:?}", x);
        let y = vec![1,2,3];
        assert!(equal_to_x(y))
    }
    ```

### 最佳实践

当指定 Fn trait bound之一时，首先用Fn，基于闭包体里的情况，如果需要FnOnce 或 FnMut，编译器会告诉你。


