## 函数

### 短小

函数的第一规则是要短小。第二条规则是还要更短小。

#### 代码块和锁进

if语句，else语句，while语句等，其中的代码应该只有一行。该行大抵是一个函数调用。这样不仅能保持函数短小，而且因为块内调用的函数拥有较具说明性的名称， 从而增加了文档上的价值。

### 只做一件事

函数的规则应该是只做一件事，做好这件事。只做这一件事

### 每个函数一个抽象层级

确保函数只做一件，函数中的语句都要在同一抽象层级上。

**自顶向下读代码：向下规则**

想要让代码拥有自顶向下的阅读顺序。我们想要让每个函数后面都跟着位于下一抽象层级的函数,这样一来,在查看函数列表时,就能循抽象层级向下阅读了。我把这叫做向下规则。

### switch 语句

写出短小的switch语句很难，写出只做一件事的switch语句也很暗。switch语句天生要做N件事。但通常又无法避免switch语句。
利用多态来实现这一点。
```java
public Money calculatePay (Employee e)
    throws InvalidEmployeeType {
        switch (e.type) {
            case COMMISSIONED:
                return calculateCommissionedPay (e);
            case HOURLY:
                return calculateHourlyPay (e);
            case SALARIED:
                return calculateSalariedPay (e);
            default:
                throw new InvalidEmployeeType (e.type);
    }
}
```

该方式存在的问题：
* 太长，当出现新的雇员类型时,还会变得更长。
* 明显做了不止一件事
* 它违反了单一权责原则(Single Responsibility Principle”, SRP)
* 它违反了开放闭合原则(Open Closed Principle', OCP)，因为每当添加新类型时,就必须修改之

该问题的解决方案是将switch 语句埋到抽象工厂'底下,不让任
何人看到。该工厂使用 switch 语句为 Employee 的派生物创建适当的实体,而不同的函数,如calculatePay、isPayday 和deliverPay 等,则藉由 Employee 接口多态地接受派遣。

```java
public abstract class Employee {
    public abstract boolean isPayday ();
    public abstract Money calculatePay ();
    public abstract void deliverPay (Money pay);
}
public interface EmployeeFactory {
    public Employee makeEmployee (EmployeeRecord r) throws InvalidEmployeeType;
}

public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee (EmployeeRecord r) throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee (r)
            case HOURLY:
                return new HourlyEmployee (r);
            case SALARIED:
                return new SalariedEmploye (r);
            default:
                throw new InvalidEmployeeType (r.type);
        }
    }
}
```

### 使用描述性名称

使用描述性的名称可以很好的描述函数做的数，这就是为什么要函数短小，函数越短小，功能越集中，就越便于取个好名字。

### 函数参数

最理想的函数参数是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应该尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）。少的参数更容易让人理解，从测试角度来看也更方便。

#### 一元函数

* 操作该参数
* 事件，有输入参数而无输出参数。（使用改参数修改系统状态）

#### 标识参数

禁止传参标识参数，传递标识参数时就意味着该函数不止做一件事。

#### 二元函数

二元参数要比一元参数难以理解，如：
```java
writeField(name)
```
比
```java
writeField(outputStream,name)
```
更清晰。另外也需要注意二元函数参数的位置。使用二元函数时应尽量将二元函数转换为一元函数，如: outputStream.writeField(name)。

#### 三元函数

有三个参数的函数要比二元函数难懂得多。排序、琢磨、忽略的问题都会加倍体现。建
议你在写三元函数前一定要想清楚。

#### 参数对象

如果函数看来需要两个、三个或三个以上参数,就说明其中一些参数应该封装为类了。

例如,下面两个声明的差别:
```java
Circle makeCircle (double x, double y, double radius);
Circle makeCircle (Point center, double radius);
```

从参数创建对象,从而减少参数数量,看起来像是在作弊,但实则并非如此。当一组参
数被共同传递,就像上例中的x和y 那样,往往就是该有自己名称的某个概念的一部分。

#### 参数列表

同理,有可变参数的函数可能是一元、二元甚至三元。超过这个数量就可能要犯错了。
```java
void monad (Integer... args);
void dyad (String name, Integer... args);.
void triad (String name, int count, Integer... args);
```

### 动词与关键字

给函数取个好名字,能较好地解释函数的意图,以及参数的顺序和意图。对于一元函数,
函数和参数应当形成一种非常良好的动词/名词对形式。例如: write(name)就相当令人认同。

不管这个“name”是什么,都要被“write”。更好的名称大概是 writeField(name),它告诉我们,“name”是一个“field”。最后那个例子展示了函数名称的关键字(keyword)形式.

### 无副作用



